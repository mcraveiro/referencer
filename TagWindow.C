
#include <gtkmm.h>
#include <libgnomeuimm.h>
#include <libgnomevfsmm.h>

// for ostringstream
#include <sstream>

#include "TagWindow.h"
#include "TagList.h"
#include "DocumentList.h"

#include "LibraryParser.h"

int main (int argc, char **argv)
{
	Gnome::Main gui ("TagWindow", "0.0.0",
		Gnome::UI::module_info_get(), argc, argv);

	Gnome::Vfs::init ();

	TagWindow window;
	
	window.run();

	return 0;
}


void TagWindow::populateDocIcons ()
{
	Glib::RefPtr<Gnome::UI::ThumbnailFactory> thumbfac = 
		Gnome::UI::ThumbnailFactory::create (Gnome::UI::THUMBNAIL_SIZE_NORMAL);

	// Should save selection and restore at end
	iconstore_->clear ();

	// Populate from doclist_
	std::vector<Document>& docvec = doclist_->getDocs();
	std::vector<Document>::iterator docit = docvec.begin();
	std::vector<Document>::iterator const docend = docvec.end();
	for (; docit != docend; ++docit) {
		bool filtered = true;
		for (std::vector<int>::iterator tagit = filtertags_.begin();
		     tagit != filtertags_.end(); ++tagit) {
			if (*tagit == ALL_TAGS_UID || (*docit).hasTag(*tagit)) {
				filtered = false;
				break;
			}
		}
		if (filtered)
			continue;
		
		Gtk::TreeModel::iterator item = iconstore_->append();
		(*item)[docnamecol_] = (*docit).getDisplayName();
		// PROGRAM CRASHING THIS HOLIDAY SEASON?
		// THIS LINE DID IT!
		// WHEE!  LOOK AT THIS LINE OF CODE!
		(*item)[docpointercol_] = &(*docit);
		
		std::string pdffile = (*docit).getFileName();
		//std::cerr << "pdf file " << pdffile << std::endl;
		
		time_t mtime;
		Glib::RefPtr<Gnome::Vfs::Uri> uri = Gnome::Vfs::Uri::create (pdffile);
		if (!uri->uri_exists()) {
			std::cerr << "File " << pdffile <<
				" does not exist, can't thumbnail" << std::endl;
			continue;
		}
		Glib::RefPtr<Gnome::Vfs::FileInfo> fileinfo = uri->get_file_info ();
		mtime = fileinfo->get_modification_time ();
		//std::cerr << "mtime " << mtime << std::endl;
		
		std::string thumbfile;
		thumbfile = thumbfac->lookup (pdffile, mtime);
		//std::cerr << "thumbnail file " << thumbfile << std::endl;
		
		Glib::RefPtr<Gdk::Pixbuf> thumbnail;
		if (thumbfile.empty()) {
			std::cerr << "Couldn't get thumbnail for " << pdffile << "\n";
		} else {
			thumbnail = Gdk::Pixbuf::create_from_file(thumbfile);
		}
		
		std::auto_ptr<Glib::Error> error;
		(*item)[docthumbnailcol_] = thumbnail;
	}
	
	// Should restore initial selection here
	
}


void TagWindow::populateTagList ()
{
	tagstore_->clear();

	// Should save selection and restore at end

	Gtk::TreeModel::iterator all = tagstore_->append();
	(*all)[taguidcol_] = ALL_TAGS_UID;
	(*all)[tagnamecol_] = "<b>All</b>";

	// Populate from taglist_
	std::vector<Tag> tagvec = taglist_->getTags();
	std::vector<Tag>::iterator it = tagvec.begin();
	std::vector<Tag>::iterator const end = tagvec.end();
	for (; it != end; ++it) {
		Gtk::TreeModel::iterator item = tagstore_->append();
		(*item)[taguidcol_] = (*it).uid_;
		(*item)[tagnamecol_] = (*it).name_;
	}
	
	// Should restore original selection
	// instead just select first row
	tagselection_->select (tagstore_->children().begin());
}


void TagWindow::run ()
{
	Gnome::Main::run (*window_);
}


void TagWindow::constructUI ()
{
	window_ = new Gtk::Window(Gtk::WINDOW_TOPLEVEL);
	window_->set_default_size (500, 500);
	/*window_->signal_delete_event().connect (
		sigc::mem_fun (*this, &TagWindow::onQuit));*/

	constructMenu ();

	Gtk::VBox *vbox = Gtk::manage(new Gtk::VBox);
	window_->add (*vbox);
	
	vbox->pack_start (*uimanager_->get_widget("/MenuBar"), false, false, 0);
	Gtk::HPaned *hpaned = Gtk::manage(new Gtk::HPaned());
	vbox->pack_start (*hpaned, true, true, 6);
	
	vbox = Gtk::manage(new Gtk::VBox);
	hpaned->pack1(*vbox, Gtk::FILL);

	// Create the store for the tag list
	Gtk::TreeModel::ColumnRecord tagcols;
	tagcols.add(taguidcol_);
	tagcols.add(tagnamecol_);
	tagstore_ = Gtk::ListStore::create(tagcols);


	// Create the treeview for the tag list
	Gtk::TreeView *tags = new Gtk::TreeView(tagstore_);
	//tags->append_column("UID", taguidcol_);
	Gtk::CellRendererText *render = Gtk::manage(new Gtk::CellRendererText());
	Gtk::TreeView::Column *namecol = Gtk::manage(
		new Gtk::TreeView::Column ("Tags", *render));
	namecol->add_attribute (render->property_markup (), tagnamecol_);
	tags->append_column (*namecol);
	tags->signal_button_press_event().connect_notify(
		sigc::mem_fun (*this, &TagWindow::tagClicked));

	tagselection_ = tags->get_selection();
	tagselection_->signal_changed().connect_notify (
		sigc::mem_fun (*this, &TagWindow::tagSelectionChanged));
	tagselection_->set_mode (Gtk::SELECTION_MULTIPLE);

	
	// Frame it and put it in the HPaned
	Gtk::Frame *tagsframe = new Gtk::Frame ();
	tagsframe->add(*tags);
	vbox->pack_start(*tagsframe, true, true, 0);
	
	Gtk::Toolbar& tagbar = (Gtk::Toolbar&) *uimanager_->get_widget("/TagBar");
	vbox->pack_start (tagbar, false, false, 0);
	tagbar.set_toolbar_style (Gtk::TOOLBAR_ICONS);
	tagbar.set_show_arrow (false);
	
	vbox = Gtk::manage(new Gtk::VBox);

	// Create the store for the document icons
	Gtk::TreeModel::ColumnRecord iconcols;
	iconcols.add(docpointercol_);
	iconcols.add(docnamecol_);
	iconcols.add(docthumbnailcol_);
	iconstore_ = Gtk::ListStore::create(iconcols);

	// Create the IconView for the document icons
	Gtk::IconView *icons = new Gtk::IconView(iconstore_);
	icons->set_text_column(docnamecol_);
	icons->set_pixbuf_column(docthumbnailcol_);
	icons->signal_item_activated().connect (
		sigc::mem_fun (*this, &TagWindow::docActivated));
		
	icons->signal_button_press_event().connect(
		sigc::mem_fun (*this, &TagWindow::docClicked));
		
	icons->signal_selection_changed().connect(
		sigc::mem_fun (*this, &TagWindow::docSelectionChanged));
	
	icons->set_selection_mode (Gtk::SELECTION_MULTIPLE);
	
	docsview_ = icons;
	
	Gtk::ScrolledWindow *scroll = Gtk::manage(new Gtk::ScrolledWindow());
	scroll->add(*icons);
	scroll->set_policy (Gtk::POLICY_NEVER, Gtk::POLICY_AUTOMATIC);
	
	Gtk::Toolbar& docbar = (Gtk::Toolbar&) *uimanager_->get_widget("/DocBar");
	vbox->pack_start (docbar, false, false, 0);
	tagbar.set_toolbar_style (Gtk::TOOLBAR_ICONS);
	tagbar.set_show_arrow (false);
	
	// Frame it and put it in the HPaned
	Gtk::Frame *iconsframe = new Gtk::Frame ();
	iconsframe->add(*scroll);
	vbox->pack_start(*iconsframe, true, true, 0);
	hpaned->pack2(*vbox, Gtk::EXPAND);
}


void TagWindow::constructMenu ()
{
	actiongroup_ = Gtk::ActionGroup::create();

	actiongroup_->add ( Gtk::Action::create("LibraryMenu", "_Library") );
	actiongroup_->add( Gtk::Action::create("ExportBibtex",
		Gtk::Stock::CONVERT, "E_xport to BibTeX"),
  	sigc::mem_fun(*this, &TagWindow::onExportBibtex));
	actiongroup_->add( Gtk::Action::create("Quit", Gtk::Stock::QUIT),
  	sigc::mem_fun(*this, &TagWindow::onQuit));

	actiongroup_->add ( Gtk::Action::create("TagMenu", "_Tags") );
	actiongroup_->add( Gtk::Action::create(
		"CreateTag", Gtk::Stock::NEW, "_Create Tag"),
  	sigc::mem_fun(*this, &TagWindow::onCreateTag));
	actiongroup_->add( Gtk::Action::create(
		"DeleteTag", Gtk::Stock::DELETE, "_Delete Tag"),
  	sigc::mem_fun(*this, &TagWindow::onDeleteTag));
	actiongroup_->add( Gtk::Action::create(
		"RenameTag", Gtk::Stock::EDIT, "_Rename Tag"),
  	sigc::mem_fun(*this, &TagWindow::onRenameTag));
  	
	actiongroup_->add ( Gtk::Action::create("DocMenu", "_Documents") );
	actiongroup_->add( Gtk::Action::create(
		"AddDoc", Gtk::Stock::ADD, "_Add Document"),
  	sigc::mem_fun(*this, &TagWindow::onAddDoc));
	actiongroup_->add( Gtk::Action::create(
		"RemoveDoc", Gtk::Stock::REMOVE, "_Remove Document"),
  	sigc::mem_fun(*this, &TagWindow::onRemoveDoc));

	uimanager_ = Gtk::UIManager::create ();
	uimanager_->insert_action_group (actiongroup_);
	Glib::ustring ui = 
		"<ui>"
		"  <menubar name='MenuBar'>"
		"    <menu action='LibraryMenu'>"
		"      <menuitem action='ExportBibtex'/>"
		"      <menuitem action='Quit'/>"
		"    </menu>"
		"    <menu action='TagMenu'>"
		"      <menuitem action='CreateTag'/>"
		"      <menuitem action='DeleteTag'/>"
		"      <menuitem action='RenameTag'/>"
		"    </menu>"
		"    <menu action='DocMenu'>"
		"      <menuitem action='AddDoc'/>"
		"      <menuitem action='RemoveDoc'/>"
		"    </menu>"
		"  </menubar>"
		"  <toolbar name='TagBar'>"
		"    <toolitem action='CreateTag'/>"
		"    <toolitem action='DeleteTag'/>"
		"  </toolbar>"
		"  <popup name='DocPopup'>"
		"    <menuitem action='AddDoc'/>"
		"    <menuitem action='RemoveDoc'/>"
		"  </popup>"
		"  <popup name='TagPopup'>"
		"    <menuitem action='CreateTag'/>"
		"    <menuitem action='DeleteTag'/>"
		"  </popup>"
		//"  <menuitem action='AddDoc' name='AddDocItem'/>"
		"</ui>";
	
	uimanager_->add_ui_from_string (ui);
	
	window_->add_accel_group (uimanager_->get_accel_group ());
}


TagWindow::TagWindow ()
{
	taglist_ = new TagList();
	/*int griduid = taglist_->newTag("Grid", Tag::ATTACH);
	int ompuid = taglist_->newTag("OpenMP", Tag::ATTACH);*/
	
	doclist_ = new DocumentList();
	//Document *mydoc;
	/*doclist_->newDoc("file:///home/jcspray/Desktop/sc06/pap104.pdf");
	mydoc = doclist_->newDoc("file:///home/jcspray/Desktop/sc06/pap107.pdf");
	mydoc->setTag(griduid);
	doclist_->newDoc("file:///home/jcspray/Desktop/sc06/pap108.pdf");
	mydoc = doclist_->newDoc("file:///home/jcspray/Desktop/sc06/pap119.pdf");
	mydoc->setTag(ompuid);
	mydoc = doclist_->newDoc("file:///home/jcspray/Desktop/sc06/pap122.pdf");
	mydoc->setTag(griduid);
	mydoc->setTag(ompuid);*/

	loadLibrary ();

	constructUI ();
	populateDocIcons ();
	populateTagList ();
	window_->show_all ();
}

TagWindow::~TagWindow ()
{
	saveLibrary ();
}


void TagWindow::docActivated (const Gtk::TreeModel::Path& path)
{
	Gtk::ListStore::iterator it = iconstore_->get_iter (path);
	Document *doc = (*it)[docpointercol_];
	std::cerr <<  doc << std::endl;
	std::cerr << doc->getFileName() << std::endl;
	Gnome::Vfs::url_show (doc->getFileName());
}


void TagWindow::tagSelectionChanged ()
{
	Gtk::TreeSelection::ListHandle_Path paths =
		tagselection_->get_selected_rows ();
	
	filtertags_.clear();
	
	bool allselected = false;
	bool anythingselected = false;
	
	if (paths.empty()) {
		allselected = true;
		anythingselected = true;
		filtertags_.push_back(ALL_TAGS_UID);
	} else {
		Gtk::TreeSelection::ListHandle_Path::iterator it = paths.begin ();
		Gtk::TreeSelection::ListHandle_Path::iterator const end = paths.end ();
		for (; it != end; it++) {
			anythingselected = true;
			Gtk::TreePath path = (*it);
			Gtk::ListStore::iterator iter = tagstore_->get_iter (path);
			filtertags_.push_back((*iter)[taguidcol_]);
			if ((*iter)[taguidcol_] == ALL_TAGS_UID) {
				allselected = true;
				break;
			}
		}
	}
	
	actiongroup_->get_action("DeleteTag")->set_sensitive (
		anythingselected && !allselected);
	actiongroup_->get_action("RenameTag")->set_sensitive (
		paths.size() == 1 && !allselected);
	
	populateDocIcons ();
}


void TagWindow::docSelectionChanged ()
{
	actiongroup_->get_action("RemoveDoc")->set_sensitive (
		!docsview_->get_selected_items().empty());
}


bool TagWindow::docClicked (GdkEventButton* event)
{
  if((event->type == GDK_BUTTON_PRESS) && (event->button == 3)) {
		Gtk::TreeModel::Path clickedpath =
			docsview_->get_path_at_pos ((int)event->x, (int)event->y);

		if (clickedpath.empty()) {
			if (docsview_->get_selected_items().empty()) {
				std::cerr << "Nothing clicked, nothing selected\n";
				return true;
			}
		} else {
			if (!docsview_->path_is_selected (clickedpath)) {
				docsview_->unselect_all ();
				docsview_->select_path (clickedpath);
			}
		}
		// Should also check if we're currently multiple-item selected
		// in which case don't reset selection

		
		/*doccontextmenu_.items().clear();
		
		for (std::vector<Tag>::iterator tagit = taglist_->getTags().begin();
		     tagit != taglist_->getTags().end(); ++tagit) {
			Gtk::CheckMenuItem *item = Gtk::manage (new Gtk::CheckMenuItem((*tagit).name_));
			YesNoMaybe state = selectedDocsHaveTag ((*tagit).uid_);
			if (state == YES) {
				std::cerr << (*tagit).name_ << " : " << "Yes\n";
				item->set_active (true);
			} else if (state == MAYBE) {
				std::cerr << (*tagit).name_ << " : " << "Maybe\n";
				item->set_inconsistent (true);
				std::cerr << item->get_inconsistent() << std::endl;
			}
			doccontextmenu_.append(*item);
		}
		
		doccontextmenu_.show_all();
		doccontextmenu_.popup (event->button, event->time);*/
		
		Gtk::Menu *popupmenu = 
			(Gtk::Menu*)uimanager_->get_widget("/DocPopup");
		popupmenu->popup (event->button, event->time);
		
		return true;
  } else {
  	return false;
  }
}


TagWindow::YesNoMaybe TagWindow::selectedDocsHaveTag (int uid)
{
	bool alltrue = true;
	bool allfalse = true;
	
	Gtk::IconView::ArrayHandle_TreePaths paths = docsview_->get_selected_items ();

	Gtk::IconView::ArrayHandle_TreePaths::iterator it = paths.begin ();
	Gtk::IconView::ArrayHandle_TreePaths::iterator const end = paths.end ();
	for (; it != end; it++) {
		Gtk::TreePath path = (*it);
		Gtk::ListStore::iterator iter = iconstore_->get_iter (path);
		Document *doc = (*iter)[docpointercol_];
		if (doc->hasTag(uid)) {
			allfalse = false;
		} else {
			alltrue = false;
		}
	}
	
	if (allfalse == true)
		return NO;
	else if (alltrue == true)
		return YES;
	else if (alltrue == false && allfalse == false)
		return MAYBE;
	else
		return NO;
}


void TagWindow::tagClicked (GdkEventButton* event)
{
  if((event->type == GDK_BUTTON_PRESS) && (event->button == 3)) {
		Gtk::Menu *popupmenu = 
			(Gtk::Menu*)uimanager_->get_widget("/TagPopup");
		popupmenu->popup (event->button, event->time);
	}
}


void TagWindow::onQuit (/*GdkEventAny *ev*/)
{
	Gnome::Main::quit ();
}


void TagWindow::onCreateTag  ()
{
	// For intelligent tags we'll need a dialog here.
	taglist_->newTag ("Unnamed Tag", Tag::ATTACH);
	populateTagList();
	// When we add a tag we need to escape it to avoid markup
}


void TagWindow::onDeleteTag ()
{
	Gtk::TreeSelection::ListHandle_Path paths =
		tagselection_->get_selected_rows ();
	
	if (paths.empty()) {
		std::cerr << "Warning: TagWindow::onDeleteTag: nothing selected\n";
		return;
	}
	
	bool somethingdeleted = false;
	
	Gtk::TreeSelection::ListHandle_Path::iterator it = paths.begin ();
	Gtk::TreeSelection::ListHandle_Path::iterator const end = paths.end ();
	for (; it != end; it++) {
		Gtk::TreePath path = (*it);
		Gtk::ListStore::iterator iter = tagstore_->get_iter (path);
		std::cerr << (*iter)[taguidcol_] << std::endl;
		if ((*iter)[taguidcol_] == ALL_TAGS_UID) {
			std::cerr << "Warning: TagWindow::onDeleteTag:"
				" someone tried to delete 'All'\n";
			continue;
		}
		
		Glib::ustring message =
			"<b><big>Are you sure you want to delete \""
			+ (*iter)[tagnamecol_]
			+"\"?</big></b>\n\n"
			+ "When a tag is deleted it is also permanently removed "
			+ "from all documents it is currently associated with";
		
		Gtk::MessageDialog confirmdialog (
			message, true, Gtk::MESSAGE_QUESTION,
			Gtk::BUTTONS_NONE, true);
		
		confirmdialog.add_button (Gtk::Stock::CANCEL, 0);
		confirmdialog.add_button (Gtk::Stock::DELETE, 1);
		
		if (confirmdialog.run ()) {
			// Remove tag from tagged documents
			doclist_->clearTag ((*iter)[taguidcol_]);
			// Delete tag
			taglist_->deleteTag ((*iter)[taguidcol_]);
			somethingdeleted = true;
		}
	}
	
	if (somethingdeleted)
		populateTagList ();
}


void TagWindow::onRenameTag ()
{
}


void TagWindow::onExportBibtex ()
{
	
}


void TagWindow::onAddDoc ()
{
	static Glib::ustring startlocation = "";
	
	Gtk::FileChooserDialog chooser(
		"Add Document",
		Gtk::FILE_CHOOSER_ACTION_OPEN);
	
	chooser.set_select_multiple (true);
	chooser.set_local_only (false);
	chooser.set_current_folder (startlocation);
	chooser.add_button (Gtk::Stock::CANCEL, Gtk::RESPONSE_REJECT);
	chooser.add_button (Gtk::Stock::ADD, Gtk::RESPONSE_ACCEPT);
	
	bool doclistdirty = false;

	int result = chooser.run ();
	if (result == Gtk::RESPONSE_ACCEPT) {
		startlocation = Glib::path_get_dirname(chooser.get_filename());
		Glib::SListHandle<Glib::ustring> uris = chooser.get_uris ();
		Glib::SListHandle<Glib::ustring>::iterator iter = uris.begin();
		Glib::SListHandle<Glib::ustring>::iterator const end = uris.end();
		for (; iter != end; ++iter) {
			//std::cerr << (*iter) << std::endl;
			doclist_->newDoc(*iter);
			doclistdirty = true;
		}
	}
	
	if (doclistdirty)
		populateDocIcons ();
}


void TagWindow::onRemoveDoc ()
{
	Gtk::IconView::ArrayHandle_TreePaths paths = docsview_->get_selected_items ();

	bool const multiple = paths.size() > 1;
	
	bool doclistdirty = false;
	
	if (multiple) {
		// Do you really want to remove N documents?
		std::ostringstream num;
		num << paths.size ();
		Glib::ustring message = "<b><big>Are you sure you want to remove these "
			+ num.str() + " documents?</big></b>\n\nAll tag "
			"associations and metadata for these documents will be permanently lost.";
		Gtk::MessageDialog confirmdialog (
			message, true, Gtk::MESSAGE_QUESTION,
			Gtk::BUTTONS_NONE, true);
		
		confirmdialog.add_button (Gtk::Stock::CANCEL, 0);
		confirmdialog.add_button (Gtk::Stock::REMOVE, 1);
		
		if (!confirmdialog.run()) {
			return;
		}
	}
	
	Gtk::IconView::ArrayHandle_TreePaths::iterator it = paths.begin ();
	Gtk::IconView::ArrayHandle_TreePaths::iterator const end = paths.end ();
	for (; it != end; it++) {
		Gtk::TreePath path = (*it);
		Gtk::ListStore::iterator iter = iconstore_->get_iter (path);
		if (!multiple) {
			Glib::ustring message = "<b><big>Are you sure you want to remove '" +
				(*iter)[docnamecol_] + "'?</big></b>\n\nAll tag "
				"associations and metadata for the document will be permanently lost.";
			Gtk::MessageDialog confirmdialog (
				message, true, Gtk::MESSAGE_QUESTION,
				Gtk::BUTTONS_NONE, true);
			
			confirmdialog.add_button (Gtk::Stock::CANCEL, 0);
			confirmdialog.add_button (Gtk::Stock::REMOVE, 1);
			
			if (!confirmdialog.run()) {
				continue;
			}
		}

		doclist_->removeDoc((*iter)[docnamecol_]);
		doclistdirty = true;
	}
	
	if (doclistdirty)
		populateDocIcons ();
}


Glib::ustring TagWindow::writeXML ()
{
	std::ostringstream out;
	out << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
	out << "<library>\n";
	taglist_->writeXML (out);
	doclist_->writeXML (out);
	out << "</library>\n";
	return out.str ();
}


void TagWindow::readXML (Glib::ustring XMLtext)
{
	taglist_->clear();
	doclist_->clear();
	LibraryParser parser (*taglist_, *doclist_);
	Glib::Markup::ParseContext context (parser);
	try {
		context.parse (XMLtext);
	} catch (Glib::MarkupError const ex) {
		std::cerr << "Exception on line " << context.get_line_number () << ", character " << context.get_char_number () << ", code ";
		switch (ex.code()) {
			case Glib::MarkupError::BAD_UTF8:
				std::cerr << "Bad UTF8\n";
				break;
			case Glib::MarkupError::EMPTY:
				std::cerr << "Empty\n";
				break;
			case Glib::MarkupError::PARSE:
				std::cerr << "Parse error\n";
				break;
			default:
				std::cerr << (int)ex.code() << "\n";
		}
	}
	context.end_parse ();
}


void TagWindow::loadLibrary ()
{
	Gnome::Vfs::Handle libfile;
	
	/*Glib::ustring libfilename =
		Gnome::Vfs::expand_initial_tilde("~/.pdfdivine.lib");*/
	Glib::ustring libfilename = "/home/jcspray/.pdfdivine.lib";
		
	Glib::RefPtr<Gnome::Vfs::Uri> liburi = Gnome::Vfs::Uri::create (libfilename);
	
	bool exists = liburi->uri_exists ();
	if (!exists) {
		std::cerr << "TagWindow::loadLibrary: Library file '" <<
			libfilename << "' not found\n";
		return;
	}
	
	libfile.open (libfilename, Gnome::Vfs::OPEN_READ);
	
	Glib::RefPtr<Gnome::Vfs::FileInfo> fileinfo;
	fileinfo = libfile.get_file_info ();
	
	char *buffer = (char *) malloc (sizeof(char) * (fileinfo->get_size() + 1));
	libfile.read (buffer, fileinfo->get_size());
	buffer[fileinfo->get_size()] = 0;
	
	Glib::ustring rawtext = buffer;
	free (buffer);
	libfile.close ();
	readXML (rawtext);
}


void TagWindow::saveLibrary ()
{
	Gnome::Vfs::Handle libfile;
	
	/*Glib::ustring libfilename =
		Gnome::Vfs::expand_initial_tilde("~/.pdfdivine.lib");*/
	Glib::ustring libfilename = "/home/jcspray/.pdfdivine.lib";

	try {
		libfile.create (libfilename, Gnome::Vfs::OPEN_WRITE,
			false, Gnome::Vfs::PERM_USER_READ | Gnome::Vfs::PERM_USER_WRITE);
	} catch (const Gnome::Vfs::exception ex) {
		std::cerr << "TagWindow::saveLibrary: "
			"exception in create '" << ex.what() << "'\n";
		return;
	}

	Glib::ustring rawtext = writeXML ();
	
	libfile.write (rawtext.c_str(), strlen(rawtext.c_str()));
	
	libfile.close ();
}
